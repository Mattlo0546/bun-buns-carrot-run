<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>BunBun‚Äôs Carrot Run ‚Äî standalone</title>
<style>
  /* =====================
     Minimal CSS & Layout
     ===================== */
  :root {
    --bg: #0b1020;
    --ink: #f6f7fb;
    --accent: #ffb84d;
    --ui: #1a2138;
    --ui-2: #2a3355;
    --heart: #ff4d6d;
    --hudShadow: rgba(0,0,0,0.6);
  }
  html, body {
    margin: 0; height: 100%; background: var(--bg); color: var(--ink);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    overscroll-behavior: none;
    touch-action: none;
  }
  #wrap { position: relative; width: 100%; height: 100vh; overflow: hidden; }
  canvas { display: block; width: 100%; height: 100%; background: #87c5ff; image-rendering: pixelated; }
  .overlay { position: absolute; inset: 0; pointer-events: none; }
  .titleUI, .pauseUI, .endUI { position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none; }
  .panel { pointer-events: auto; background: linear-gradient(180deg, var(--ui), var(--ui-2)); color: var(--ink);
           border: 2px solid #0008; border-radius: 16px; padding: 20px 24px; box-shadow: 0 12px 40px #0009; max-width: 720px; }
  .title { font-size: 36px; line-height: 1.1; text-align: center; text-shadow: 0 3px 0 #000a, 0 0 12px #fff2; margin: 0 0 8px; }
  .subtitle { text-align: center; opacity: .9; margin: 0 0 16px; }
  .row { display: flex; gap: 12px; align-items: center; justify-content: center; flex-wrap: wrap; }
  button { pointer-events: auto; appearance: none; font: inherit; color: #111; background: var(--accent); border: 0; border-radius: 12px;
           padding: 10px 14px; box-shadow: inset 0 -2px 0 #0004, 0 4px 0 #0007; cursor: pointer; }
  button:active { transform: translateY(1px); box-shadow: inset 0 -1px 0 #0004, 0 3px 0 #0005; }
  .mutetoggle { background: #e8eefc; }
  .credits { text-align: center; font-size: 12px; opacity: .8; margin-top: 10px; }
  .hud { position: absolute; left: 12px; top: 8px; display: flex; gap: 12px; align-items: center; font-weight: 700; text-shadow: 0 2px 0 var(--hudShadow); }
  .hud .pill { background: #0006; padding: 6px 8px; border-radius: 10px; border: 1px solid #fff2; }
  .hud .heart { color: var(--heart); }
  .hud .icon { width: 18px; height: 18px; display: inline-block; vertical-align: text-bottom; margin-right: 4px; }
  .topRight { position: absolute; right: 8px; top: 8px; display: flex; gap: 8px; }
  .smallBtn { font-size: 12px; padding: 8px 10px; background: #dfe6ff; }

  /* Mobile touch controls */
  #touch { position: absolute; inset: 0; pointer-events: none; }
  .touchpad { position: absolute; bottom: 18px; left: 18px; display: grid; grid-template-columns: 64px 64px; grid-template-rows: 64px; gap: 12px; }
  .touchbtn { width: 64px; height: 64px; border-radius: 16px; background: #ffffff26; border: 2px solid #ffffff55; box-shadow: inset 0 -2px 0 #0004; pointer-events: auto; }
  .touchbtn:active { transform: translateY(1px); }
  .touchRight { position: absolute; bottom: 18px; right: 18px; }

  /* Accessibility: hide touch on wide screens if keyboard likely used */
  @media (hover:hover) and (pointer:fine) and (min-width: 900px) { #touch { display:none; } }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="1280" height="720"></canvas>
  <div class="overlay">
    <div class="hud" id="hud">
      <div class="pill" id="hudCarrot">ü•ï x 00</div>
      <div class="pill" id="hudLives">‚ù§ x 3</div>
      <div class="pill" id="hudPower">üëú ‚Äî</div>
      <div class="pill" id="hudTime">‚è± 0:00</div>
    </div>
    <div class="topRight">
      <button class="smallBtn" id="btnPause" title="Pause (P)">Pause</button>
      <button class="smallBtn mutetoggle" id="btnMute" title="Mute (M)">Sound: On</button>
    </div>
  </div>

  <!-- Title Screen -->
  <div class="titleUI" id="titleUI">
    <div class="panel">
      <h1 class="title">BunBun‚Äôs Carrot Run</h1>
      <p class="subtitle">A tiny side-scrolling platformer ¬∑ <strong>Collect carrots</strong>, bop <strong>foxes</strong>, and glide with the <strong>tote bag</strong>!</p>
      <div style="font-size:14px; line-height:1.5; margin: 0 0 16px; text-align:center; opacity:.95;">
        <strong>Controls</strong> ‚Äî Move: <kbd>A/D</kbd> or <kbd>‚óÄ/‚ñ∂</kbd> ¬∑ Jump/Glide: <kbd>W</kbd>/<kbd>‚ñ≤</kbd>/<kbd>Space</kbd> ¬∑ Pause: <kbd>P</kbd> ¬∑ Mute: <kbd>M</kbd><br/>
        On mobile, use the on-screen buttons.
      </div>
      <div class="row">
        <button id="btnStart">Press Enter / Tap to Start</button>
        <button id="btnTitleMute" class="mutetoggle">Sound: On</button>
      </div>
      <div class="credits">Made for a friend ‚ô°</div>
    </div>
  </div>

  <!-- Pause Screen -->
  <div class="pauseUI" id="pauseUI" style="display:none;">
    <div class="panel">
      <h2 style="margin:0 0 8px;">Paused</h2>
      <div style="opacity:.9; font-size:14px;">Press <kbd>P</kbd> or tap Resume</div>
      <div class="row" style="margin-top:12px;">
        <button id="btnResume">Resume</button>
        <button id="btnQuitToTitle">Title</button>
      </div>
    </div>
  </div>

  <!-- End Screen -->
  <div class="endUI" id="endUI" style="display:none;">
    <div class="panel" id="endPanel">
      <h2 style="margin:0 0 8px;">You did it! üéâ</h2>
      <div id="endStats" style="white-space:pre; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;"></div>
      <div style="margin:10px 0 0;">Thanks for helping BunBun! You‚Äôre totally <em>tote-ally</em> awesome.</div>
      <div class="row" style="margin-top:12px;">
        <button id="btnRestart">Restart</button>
        <button id="btnEndTitle">Title</button>
      </div>
    </div>
  </div>

  <!-- Touch controls -->
  <div id="touch">
    <div class="touchpad">
      <button class="touchbtn" id="touchLeft" aria-label="Left"></button>
      <button class="touchbtn" id="touchRight" aria-label="Right"></button>
    </div>
    <div class="touchRight">
      <button class="touchbtn" id="touchJump" aria-label="Jump"></button>
      <button class="touchbtn" id="touchPause" aria-label="Pause" style="margin-top:12px;"></button>
    </div>
  </div>
</div>

<script>
/*
=====================================================
BunBun‚Äôs Carrot Run ‚Äî Single-file HTML5 Canvas Platformer
=====================================================
- No external assets. Pixel art drawn with Canvas.
- WebAudio for music + SFX (all synthesized).
- Fixed timestep physics with tile collisions.
- Two short stages + final goal and ending.
- Tote Bag power-up: glide & one-hit protection.
- Mobile controls + keyboard, pause, title, HUD.

Author: a friendly senior web game dev üíõ
*/

// ==========================
// CONFIG ‚Äî tweakable knobs
// ==========================
const CONFIG = {
  WIDTH: 426,          // internal resolution (16:9) ‚Äî scaled with letterboxing
  HEIGHT: 240,
  CAMERA_LERP: 0.12,   // camera follow strength
  GRAVITY: 0.36,
  MOVE_SPEED: 1.2,     // walk speed per frame
  AIR_ACCEL: 0.15,
  FRICTION_GROUND: 0.8,
  FRICTION_AIR: 0.95,
  JUMP_VELOCITY: -5.2,
  COYOTE_TIME: 8,      // frames of coyote time
  JUMP_BUFFER: 8,      // frames we buffer jump input
  VAR_JUMP_CUT: 0.45,  // multiplier when releasing jump early
  GLIDE_GRAVITY: 0.12, // gravity while gliding with tote
  MAX_FALL: 7.0,
  TILE: 16,            // tile size
  SHAKE_DECAY: 0.9,
  STOMP_BOUNCE: -4.2,
  FOX_SPEED: 0.5,
  FOX_STUN_TIME: 60,
  PLAYER_MAX_LIVES: 5,
  START_LIVES: 3,
  RESPAWN_TIME: 45,
  CHECKPOINT_HEAL: 0,
  MUSIC_BPM: 132,
};

// ======================
// Canvas & Scaling
// ======================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

let DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
let viewScale = 1, viewOffsetX = 0, viewOffsetY = 0;
function resize() {
  const tw = window.innerWidth, th = window.innerHeight;
  const targetAspect = CONFIG.WIDTH / CONFIG.HEIGHT;
  const winAspect = tw / th;
  if (winAspect > targetAspect) {
    // Letterbox left/right
    viewScale = Math.floor(th * DPR / CONFIG.HEIGHT);
    viewScale = Math.max(1, viewScale);
    const scaledW = CONFIG.WIDTH * viewScale;
    const scaledH = CONFIG.HEIGHT * viewScale;
    canvas.width = scaledW; canvas.height = scaledH;
    canvas.style.width = (scaledW / DPR) + 'px';
    canvas.style.height = (scaledH / DPR) + 'px';
    viewOffsetX = Math.floor((tw - scaledW / DPR) / 2);
    viewOffsetY = 0;
    canvas.style.marginLeft = viewOffsetX + 'px';
    canvas.style.marginTop = '0px';
  } else {
    // Letterbox top/bottom
    viewScale = Math.floor(tw * DPR / CONFIG.WIDTH);
    viewScale = Math.max(1, viewScale);
    const scaledW = CONFIG.WIDTH * viewScale;
    const scaledH = CONFIG.HEIGHT * viewScale;
    canvas.width = scaledW; canvas.height = scaledH;
    canvas.style.width = (scaledW / DPR) + 'px';
    canvas.style.height = (scaledH / DPR) + 'px';
    viewOffsetX = 0;
    viewOffsetY = Math.floor((th - scaledH / DPR) / 2);
    canvas.style.marginLeft = '0px';
    canvas.style.marginTop = viewOffsetY + 'px';
  }
}
window.addEventListener('resize', resize);
resize();

// ======================
// Utilities
// ======================
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const lerp = (a,b,t)=> a+(b-a)*t;
const rnd = (a,b)=> a + Math.random()*(b-a);
const irnd = (a,b)=> Math.floor(rnd(a,b+1));

// Tiny PRNG for deterministic particles (optional)
let seed = 123456;
function rand() { seed ^= seed<<13; seed ^= seed>>>17; seed ^= seed<<5; return (seed>>>0)/4294967295; }

// ======================
// Input Handling
// ======================
const input = { left:false,right:false,up:false,jump:false, jumpHeld:false, pause:false };
const keys = new Map([
  ['ArrowLeft','left'], ['KeyA','left'],
  ['ArrowRight','right'], ['KeyD','right'],
  ['ArrowUp','up'], ['KeyW','up'], ['Space','jump'],
  ['KeyP','pause'],
  ['KeyM','mute']
]);

let mutePref = localStorage.getItem('bb_mute') === '1' ? true : false;

function setMuteUI() {
  const txt = mutePref ? 'Sound: Off' : 'Sound: On';
  document.getElementById('btnMute').textContent = txt;
  document.getElementById('btnTitleMute').textContent = txt;
}
setMuteUI();

window.addEventListener('keydown', (e)=>{
  const m = keys.get(e.code);
  if (m === 'pause') { togglePause(); e.preventDefault(); return; }
  if (m === 'mute') { toggleMute(); e.preventDefault(); return; }
  if (m === 'jump' || m === 'up') { input.jump = true; input.jumpHeld = true; }
  if (m === 'left') input.left = true;
  if (m === 'right') input.right = true;
  if (gameState === STATE.TITLE && (e.code === 'Enter' || m==='jump' || m==='up')) startGame();
});
window.addEventListener('keyup', (e)=>{
  const m = keys.get(e.code);
  if (m === 'jump' || m === 'up') input.jumpHeld = false;
  if (m === 'left') input.left = false;
  if (m === 'right') input.right = false;
});

// Touch controls
function bindTouch(id, on, off){
  const el = document.getElementById(id);
  const set = (v)=>{ on(v); };
  const unset = ()=>{ off(); };
  ['pointerdown','touchstart','mousedown'].forEach(ev=> el.addEventListener(ev, e=>{ e.preventDefault(); set(true);}));
  ['pointerup','pointerleave','touchend','touchcancel','mouseup','mouseleave'].forEach(ev=> el.addEventListener(ev, e=>{ e.preventDefault(); unset(); }));
}
bindTouch('touchLeft', v=>{input.left = true;}, ()=>{input.left=false;});
bindTouch('touchRight', v=>{input.right = true;}, ()=>{input.right=false;});
bindTouch('touchJump', v=>{input.jump = true; input.jumpHeld = true;}, ()=>{input.jumpHeld=false;});
bindTouch('touchPause', ()=> togglePause(), ()=>{});

document.getElementById('btnPause').onclick = ()=> togglePause();
document.getElementById('btnMute').onclick = ()=> toggleMute();
document.getElementById('btnStart').onclick = ()=> startGame();
document.getElementById('btnTitleMute').onclick = ()=> toggleMute();
document.getElementById('btnResume').onclick = ()=> togglePause();
document.getElementById('btnQuitToTitle').onclick = ()=> quitToTitle();
document.getElementById('btnRestart').onclick = ()=> restartFromBeginning();
document.getElementById('btnEndTitle').onclick = ()=> quitToTitle();

function toggleMute(){
  mutePref = !mutePref; localStorage.setItem('bb_mute', mutePref? '1':'0');
  if (audio.ctx) audio.setMaster(mutePref?0:1);
  setMuteUI();
}

function togglePause(){
  if (gameState !== STATE.PLAYING) return;
  paused = !paused;
  document.getElementById('pauseUI').style.display = paused? 'grid':'none';
}

function quitToTitle(){
  setState(STATE.TITLE);
}

function restartFromBeginning(){
  resetAll();
  setState(STATE.PLAYING);
}

// ======================
// Audio (WebAudio)
// ======================
const audio = {
  ctx:null, master:null,
  musicGain:null, sfxGain:null,
  init(){
    if (this.ctx) return;
    const ctx = new (window.AudioContext||window.webkitAudioContext)();
    this.ctx = ctx;
    const master = ctx.createGain(); master.gain.value= mutePref?0:1; master.connect(ctx.destination); this.master = master;
    this.musicGain = ctx.createGain(); this.musicGain.gain.value = 0.25; this.musicGain.connect(master);
    this.sfxGain = ctx.createGain(); this.sfxGain.gain.value = 0.9; this.sfxGain.connect(master);
    this.scheduleMusic();
  },
  setMaster(v){ if (this.master) this.master.gain.value = v; },
  // Basic tone synth
  beep(freq=440, dur=0.12, type='square', gain=0.35){ if(!this.ctx) return; const t=this.ctx.currentTime; const o=this.ctx.createOscillator(); const g=this.ctx.createGain();
    o.type=type; o.frequency.value=freq; o.connect(g); g.gain.value=0; g.connect(this.sfxGain);
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(gain, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t+dur);
    o.start(t); o.stop(t+dur+0.02);
  },
  noise(dur=0.1, gain=0.4){ if(!this.ctx) return; const t=this.ctx.currentTime; const buffer=this.ctx.createBuffer(1, this.ctx.sampleRate*dur, this.ctx.sampleRate);
    const data=buffer.getChannelData(0); for(let i=0;i<data.length;i++) data[i]=Math.random()*2-1;
    const src=this.ctx.createBufferSource(); src.buffer=buffer; const g=this.ctx.createGain(); g.gain.value=gain; src.connect(g); g.connect(this.sfxGain);
    g.gain.setValueAtTime(gain, t); g.gain.exponentialRampToValueAtTime(0.001, t+dur);
    src.start(t);
  },
  // Music: simple chiptune pattern in C major
  scheduleMusic(){ if(!this.ctx) return; if (this.musicNode) { this.musicNode.stop(); this.musicNode.disconnect(); }
    // We'll sequence via setInterval + quick envelopes (low-tech but sufficient for demo)
    const bpm = CONFIG.MUSIC_BPM; const spb = 60/bpm; const beatMs = spb*1000;
    const notes = [ // I-V-vi-IV style loop: C G Am F (arps)
      [261.63,329.63,392.00], [196.00,246.94,392.00], [220.00,261.63,329.63], [174.61,220.00,261.63]
    ];
    let step=0; clearInterval(this.musicTimer);
    this.musicTimer = setInterval(()=>{
      if (!this.ctx) return; // safety
      // chord arpeggio
      const chord = notes[Math.floor(step/4)%notes.length];
      const n = chord[step%3];
      // Square lead blip
      this.beep(n, 0.10, 'square', 0.15);
      // Simple kick/snare pattern
      const m = step % 8;
      if (m===0) this.noise(0.03, 0.25); // snare-ish
      if (m===4) this.noise(0.02, 0.18); // soft
      step=(step+1)%32;
    }, beatMs/2);
  },
  playJump(){ this.beep(523.25,0.12,'square',0.25); },
  playLand(){ this.noise(0.04,0.25); },
  playCarrot(){ this.beep(880,0.08,'triangle',0.28); this.beep(1174.66,0.08,'square',0.22); },
  playStomp(){ this.beep(220,0.06,'square',0.35); this.beep(440,0.08,'square',0.22); },
  playHurt(){ this.noise(0.1,0.4); this.beep(160,0.2,'sawtooth',0.2); },
  playTote(){ this.beep(659.25,0.1,'triangle',0.3); this.beep(987.77,0.2,'square',0.25); },
  playCheckpoint(){ this.beep(523.25,0.08,'square',0.28); this.beep(659.25,0.12,'square',0.24); },
  playGoal(){ this.beep(523.25,0.15,'square',0.35); this.beep(783.99,0.25,'square',0.35); this.beep(1046.50,0.35,'square',0.35); },
};

// Wake audio on user gesture
['click','keydown','pointerdown','touchstart'].forEach(ev=> document.addEventListener(ev, ()=> audio.init(), { once: true }));

// ======================
// Tilemap Utilities
// ======================
// Tiles: 0 = empty, 1 = dirt, 2 = grass, 3 = hard block, 4 = cloud block (decorative no-collide), 5 = moving platform (special), 6 = spike (hurt)
// We'll treat 1,2,3,6 as solid (6 is hazardous). 5 handled separately.
function solidTile(id){ return id===1||id===2||id===3; }
function hazardTile(id){ return id===6; }

// Draw tiles procedurally (simple pixel rectangles)
function drawTile(id, x,y){
  const t=CONFIG.TILE; ctx.save(); ctx.translate(x, y);
  if (id===1){ // dirt
    ctx.fillStyle = '#6b3f27'; ctx.fillRect(0,0,t,t);
    ctx.fillStyle = '#5a341f'; for(let i=0;i<3;i++) ctx.fillRect(irnd(1,12), irnd(1,14), 2,2);
  } else if (id===2){ // grass top
    ctx.fillStyle = '#6b3f27'; ctx.fillRect(0,2,t,t-2);
    ctx.fillStyle = '#3fbf5a'; ctx.fillRect(0,0,t,6);
    ctx.fillStyle = '#2fa84a'; for(let i=0;i<5;i++) ctx.fillRect(irnd(0,15), irnd(0,5), 1,1);
  } else if (id===3){ // stone
    ctx.fillStyle = '#7b7f8c'; ctx.fillRect(0,0,t,t);
    ctx.fillStyle = '#5e626e'; ctx.fillRect(0,0,t,3);
    ctx.fillStyle = '#8d93a1'; for(let i=0;i<4;i++) ctx.fillRect(irnd(1,12), irnd(4,14), 2,2);
  } else if (id===4){ // cloud decor
    ctx.fillStyle = '#ffffffdd'; ctx.fillRect(2,6,12,6); ctx.fillRect(4,4,8,4);
  } else if (id===6){ // spike
    ctx.fillStyle = '#c33';
    for(let i=0;i<4;i++){ ctx.beginPath(); ctx.moveTo(i*4,16); ctx.lineTo(i*4+2,8); ctx.lineTo(i*4+4,16); ctx.closePath(); ctx.fill(); }
  }
  ctx.restore();
}

// ======================
// Level Definitions
// ======================
// Helper to make a flat layer and carve features
function emptyLevel(w,h){ const a=new Array(h); for(let y=0;y<h;y++){ a[y]=new Array(w).fill(0);} return a; }

// Stage 1: tutorial-ish
const level1 = (()=>{
  const w=120, h=20; const a=emptyLevel(w,h);
  // ground
  for(let x=0;x<w;x++){ const top = 14 + (x>20 && x<30 ? 1:0) + (x>45&&x<60? -1:0); for(let y=top;y<h;y++){ a[y][x]= (y===top)?2:1; } }
  // small platforms
  for (let x=10;x<15;x++) a[10][x]=3;
  for (let x=28;x<32;x++) a[9][x]=3;
  for (let x=50;x<56;x++) a[11][x]=3;
  // hazards
  a[15][40]=6; a[15][41]=6; a[15][42]=6;
  // carrots placed sparsely (we'll add entities separately too)
  return { w,h, tiles:a, start:[2,12], checkpoints:[[26,11]], totes:[[14,9]], carrots:[[12,9],[30,8],[44,13],[54,10],[70,12],[88,11]], foxes:[[22,13],[48,13],[66,13]], goal:null };
})();

// Stage 2: moving platforms + trickier patrols
const level2 = (()=>{
  const w=140, h=20; const a=emptyLevel(w,h);
  // base ground
  for(let x=0;x<w;x++){ const top = (x<20?14: (x<40?12: (x<80? 15:13))); for(let y=top;y<h;y++){ a[y][x]= y===top?2:1; } }
  // elevated ledges
  for (let x=22;x<28;x++) a[9][x]=3;
  for (let x=36;x<42;x++) a[8][x]=3;
  for (let x=60;x<68;x++) a[11][x]=3;
  // gaps with spikes
  a[15][50]=6; a[15][51]=6; a[15][52]=6; a[15][53]=6;
  // moving platforms marked as 5 (we'll place entity definitions)
  a[10][76]=5; a[10][84]=5;
  a[9][100]=3; a[9][101]=3; a[9][102]=3;
  return { w,h, tiles:a, start:[2,12], checkpoints:[[38,7],[90,10]], totes:[[24,8],[80,10]], carrots:[[24,7],[26,7],[38,6],[40,6],[62,10],[64,10],[66,10],[82,9],[101,8],[103,8]], foxes:[[26,13],[62,13],[95,13],[118,12]], goal:[130,12] };
})();

const levels = [level1, level2];

// Moving platform entities for stage 2
const movingPlatforms = [
  { level:1, x:76, y:10, dx:0.5, dy:0, range:6, dir:1 },
  { level:1, x:84, y:10, dx:-0.5, dy:0, range:6, dir:-1 },
];

// ======================
// Entities & State
// ======================
const STATE = { TITLE:0, PLAYING:1, PAUSED:2, END:3 };
let gameState = STATE.TITLE;
let paused = false;
let frame=0;
let globalTime=0; // in seconds
let stageIndex=0;
let camera = { x:0, y:0 };
let shake=0; // screen shake
let stats = { carrots:0, lives:CONFIG.START_LIVES, time:0 };
let player, entities, particles, pools;
let respawnTimer=0;
let lastCheckpoint = null; // {level: i, x,y}

// HUD helpers
const hudCarrot = document.getElementById('hudCarrot');
const hudLives = document.getElementById('hudLives');
const hudPower = document.getElementById('hudPower');
const hudTime = document.getElementById('hudTime');

function setState(s){
  gameState = s;
  document.getElementById('titleUI').style.display = s===STATE.TITLE? 'grid':'none';
  document.getElementById('pauseUI').style.display = (s===STATE.PAUSED)? 'grid':'none';
  document.getElementById('endUI').style.display = s===STATE.END? 'grid':'none';
}

function resetAll(){
  stageIndex = 0; stats = { carrots:0, lives:CONFIG.START_LIVES, time:0 };
  lastCheckpoint = null; initStage(stageIndex);
}

function startGame(){
  resetAll(); setState(STATE.PLAYING);
}

// ======================
// Simple Pools (particles, floats)
// ======================
class Particle {
  constructor(){ this.active=false; }
  init(x,y,vx,vy,life, color){ this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.life=life; this.t=0; this.color=color; this.active=true; }
  upd(){ if(!this.active) return; this.t++; this.x+=this.vx; this.y+=this.vy; this.vy+=0.05; if(this.t>this.life) this.active=false; }
  draw(){ if(!this.active) return; ctx.fillStyle=this.color; ctx.fillRect(Math.floor(this.x), Math.floor(this.y), 2,2); }
}
class FloatText {
  constructor(){ this.active=false; }
  init(x,y,text){ this.x=x; this.y=y; this.vy=-0.3; this.t=0; this.text=text; this.active=true; }
  upd(){ if(!this.active) return; this.t++; this.y+=this.vy; if(this.t>40) this.active=false; }
  draw(){ if(!this.active) return; ctx.fillStyle = '#fff'; ctx.font='8px monospace'; ctx.textAlign='center'; ctx.fillText(this.text, Math.floor(this.x), Math.floor(this.y)); }
}

function makePool(cls, n){ const arr=new Array(n); for(let i=0;i<n;i++) arr[i]=new cls(); return arr; }

// ======================
// Player
// ======================
class Player {
  constructor(x,y){ this.x=x; this.y=y; this.vx=0; this.vy=0; this.w=10; this.h=14; this.onGround=false; this.coyote=0; this.jumpBuffer=0; this.gliding=false; this.powerTote=false; this.invuln=0; this.anim=0; this.dir=1; this.landingSquash=0; }
  rect(){ return { x:this.x- this.w/2, y:this.y- this.h, w:this.w, h:this.h }; }
  giveTote(){ this.powerTote=true; audio.playTote(); spawnSparkle(this.x, this.y-8); }
  hurt(){ if (this.invuln>0) return; if (this.powerTote){ this.powerTote=false; this.invuln=60; // consume tote as shield
      for(let i=0;i<8;i++) spawnSpark(this.x,this.y-6,'#f5e6c8');
    } else {
      stats.lives = Math.max(0, stats.lives-1); audio.playHurt(); shake=6; respawnTimer = CONFIG.RESPAWN_TIME; this.dead=true; }
  }
  stompBounce(){ this.vy = CONFIG.STOMP_BOUNCE; audio.playStomp(); shake=3; }
}

// ======================
// Enemies
// ======================
class Fox {
  constructor(x,y){ this.x=x*CONFIG.TILE+8; this.y=(y+1)*CONFIG.TILE; this.vx=CONFIG.FOX_SPEED; this.vy=0; this.w=12; this.h=12; this.dir=1; this.stun=0; this.remove=0; }
  rect(){ return { x:this.x-this.w/2, y:this.y-this.h, w:this.w, h:this.h }; }
}

class Carrot { constructor(x,y){ this.x=x*CONFIG.TILE+8; this.y=y*CONFIG.TILE+8; this.collected=false; } }
class Tote { constructor(x,y){ this.x=x*CONFIG.TILE+8; this.y=y*CONFIG.TILE+8; this.collected=false; } }
class Checkpoint { constructor(x,y){ this.x=x*CONFIG.TILE+8; this.y=y*CONFIG.TILE; this.activated=false; } }
class Goal { constructor(x,y){ this.x=x*CONFIG.TILE+8; this.y=y*CONFIG.TILE; this.hit=false; } }
class MovePlat { constructor(x,y,dx,dy,range,dir){ this.x=x*CONFIG.TILE+8; this.y=y*CONFIG.TILE+8; this.dx=dx; this.dy=dy; this.range=range*CONFIG.TILE; this.dir=dir; this.origin={x:this.x,y:this.y}; this.w=24; this.h=6; }
  rect(){ return { x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h }; }
}

// ======================
// Stage init
// ======================
function initStage(i){
  const L = levels[i];
  // Entities
  entities = { foxes:[], carrots:[], totes:[], checkpoints:[], goal:null, plats:[] };
  for (const [cx,cy] of L.foxes) entities.foxes.push(new Fox(cx,cy));
  for (const [cx,cy] of L.carrots) entities.carrots.push(new Carrot(cx,cy));
  for (const [cx,cy] of L.totes) entities.totes.push(new Tote(cx,cy));
  for (const [cx,cy] of L.checkpoints||[]) entities.checkpoints.push(new Checkpoint(cx,cy));
  if (L.goal) entities.goal = new Goal(L.goal[0], L.goal[1]);

  // Moving plats for this level
  entities.plats = [];
  for (const mp of movingPlatforms) if (mp.level===i){ entities.plats.push(new MovePlat(mp.x, mp.y, mp.dx, mp.dy, mp.range, mp.dir)); }

  // Player
  const sx = L.start[0]*CONFIG.TILE + 8, sy = (L.start[1]+1)*CONFIG.TILE;
  player = new Player(sx, sy);

  // Particles & pools
  particles = makePool(Particle, 128);
  floaters = makePool(FloatText, 32);

  camera.x = Math.max(0, sx - CONFIG.WIDTH/2); camera.y = 0;
  respawnTimer = 0; paused=false;
}

let floaters;

// ======================
// Collision helpers
// ======================
function tileAt(L, px, py){
  const tx = Math.floor(px/CONFIG.TILE); const ty = Math.floor(py/CONFIG.TILE);
  if (tx<0||ty<0||tx>=L.w||ty>=L.h) return 0; return L.tiles[ty][tx];
}

function rectVsRect(a,b){ return !(a.x+a.w<=b.x || a.x>=b.x+b.w || a.y+a.h<=b.y || a.y>=b.y+b.h); }

// Resolve collisions on separate axes for solids
function resolveSolids(L, r, vx, vy){
  // Horizontal
  r.x += vx;
  let collidedX=false;
  const minX = Math.floor((r.x)/CONFIG.TILE)-1, maxX=Math.floor((r.x+r.w)/CONFIG.TILE)+1;
  const minY = Math.floor((r.y)/CONFIG.TILE), maxY=Math.floor((r.y+r.h)/CONFIG.TILE);
  for (let ty=minY; ty<=maxY; ty++){
    for (let tx=minX; tx<=maxX; tx++){
      const id = (tx<0||ty<0||tx>=L.w||ty>=L.h)?3: L.tiles[ty][tx];
      if (!solidTile(id)) continue;
      const tr = { x:tx*CONFIG.TILE, y:ty*CONFIG.TILE, w:CONFIG.TILE, h:CONFIG.TILE };
      if (rectVsRect(r,tr)){
        if (vx>0) r.x = tr.x - r.w; else r.x = tr.x + tr.w; collidedX=true;
      }
    }
  }
  // Vertical
  r.y += vy; let collidedY=false; let hitHead=false; let onGround=false; let hurt=false;
  const minX2 = Math.floor((r.x)/CONFIG.TILE), maxX2=Math.floor((r.x+r.w)/CONFIG.TILE);
  const minY2 = Math.floor((r.y)/CONFIG.TILE)-1, maxY2=Math.floor((r.y+r.h)/CONFIG.TILE)+1;
  for (let ty=minY2; ty<=maxY2; ty++){
    for (let tx=minX2; tx<=maxX2; tx++){
      const id = (tx<0||ty<0||tx>=L.w||ty>=L.h)?3: L.tiles[ty][tx];
      if (hazardTile(id)) hurt=true;
      if (!solidTile(id)) continue;
      const tr = { x:tx*CONFIG.TILE, y:ty*CONFIG.TILE, w:CONFIG.TILE, h:CONFIG.TILE };
      if (rectVsRect(r,tr)){
        if (vy>0){ r.y = tr.y - r.h; onGround=true; }
        else { r.y = tr.y + tr.h; hitHead=true; }
      }
    }
  }
  return { collidedX, collidedY, onGround, hitHead, hurt };
}

// ======================
// Rendering helpers
// ======================
function drawSky(){
  // gradient sky + parallax clouds
  const w=CONFIG.WIDTH, h=CONFIG.HEIGHT;
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,'#87c5ff'); g.addColorStop(1,'#cbe9ff');
  ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
  // clouds
  const t = frame*0.2;
  ctx.fillStyle='#ffffffcc';
  for (let i=0;i<6;i++){
    const cx = (i*80 - (camera.x*0.3)%480 + t) % (w+160) - 80;
    const cy = 20 + (i%3)*12;
    ctx.fillRect(cx, cy, 40,10); ctx.fillRect(cx+8, cy-4, 24,8);
  }
}

function drawLevelTiles(L){
  const t=CONFIG.TILE;
  const startX = Math.floor(camera.x / t) - 2;
  const endX = Math.floor((camera.x + CONFIG.WIDTH) / t) + 2;
  for (let y=0;y<L.h;y++){
    for (let x=Math.max(0,startX); x<Math.min(L.w,endX); x++){
      const id = L.tiles[y][x]; if (!id || id===5) continue; // 5 handled by platform draw
      drawTile(id, x*t, y*t);
    }
  }
}

function drawPlatform(p){
  ctx.fillStyle = '#b9a77a';
  ctx.fillRect(p.x - p.w/2, p.y - p.h/2, p.w, p.h);
  ctx.fillStyle = '#8b7a55'; ctx.fillRect(p.x - p.w/2, p.y - p.h/2, p.w, 2);
}

function drawCarrot(x,y){
  ctx.save(); ctx.translate(x-4,y-6); // center-ish
  ctx.fillStyle='#ff9f1c'; ctx.fillRect(2,2,4,6); // body
  ctx.fillStyle='#2ec27e'; ctx.fillRect(3,0,2,2); // leaves
  ctx.restore();
}

function drawTote(x,y){
  ctx.save(); ctx.translate(x-5,y-7); // small beige tote
  ctx.fillStyle='#f5e6c8'; ctx.fillRect(1,3,8,8);
  ctx.strokeStyle='#d8c8a8'; ctx.lineWidth=1; ctx.strokeRect(1.5,3.5,7,7);
  // handle
  ctx.fillStyle='#e6d6b6'; ctx.fillRect(2,1,6,2);
  // little embroidered motif
  ctx.fillStyle='#c59'; ctx.fillRect(4,7,2,2);
  ctx.restore();
}

function drawCheckpoint(c){
  // carrot signpost
  ctx.save();
  ctx.translate(c.x-8, c.y-16);
  ctx.fillStyle='#7a5230'; ctx.fillRect(7,4,2,12);
  ctx.fillStyle=c.activated? '#ffd166':'#ffa94d'; ctx.fillRect(0,0,8,6);
  ctx.fillStyle='#2ec27e'; ctx.fillRect(2,0,4,2);
  ctx.restore();
}

function drawGoal(g){
  // big golden carrot flag
  ctx.save(); ctx.translate(g.x-8, g.y-32);
  ctx.fillStyle='#7a5230'; ctx.fillRect(6,8,2,24);
  ctx.fillStyle='#ffd166'; ctx.fillRect(0,0,10,10);
  ctx.fillStyle='#2ec27e'; ctx.fillRect(3,0,4,3);
  ctx.restore();
}

function drawFox(f){
  // simple orange fox
  ctx.save(); ctx.translate(f.x-6, f.y-10);
  const c = f.stun>0? '#d0d0d0':'#f28c28';
  ctx.fillStyle=c; ctx.fillRect(1,4,10,6);
  ctx.fillRect(f.dir>0?6:0,2,4,4); // head
  ctx.fillStyle='#000'; ctx.fillRect(f.dir>0?9:2,3,1,1);
  ctx.fillStyle='#fff'; ctx.fillRect(f.dir>0?7:3,4,1,1);
  ctx.restore();
}

function drawBunBun(p){
  // cute off-white bunny with blue pin-striped dress
  const x = Math.floor(p.x), y = Math.floor(p.y);
  ctx.save();
  // landing squash & stretch
  const squash = p.landingSquash>0 ? 1 + 0.15*Math.sin(p.landingSquash/8) : 1;
  const stretchY = p.onGround? (2 - squash) : 1;
  ctx.translate(x, y);
  ctx.scale(1, stretchY);
  ctx.translate(0, -p.h);

  // Body (fur)
  ctx.fillStyle='#f4f1e8';
  ctx.fillRect(-5, 2, 10, 10); // torso
  ctx.fillRect(-4, -2, 8, 6);  // head
  // Ears
  ctx.fillRect(-4, -8, 3, 6);
  ctx.fillRect(1, -8, 3, 6);
  ctx.fillStyle='#f6b1c3'; // inner ear + nose
  ctx.fillRect(-3, -7, 1, 3);
  ctx.fillRect(3, -7, 1, 3);
  ctx.fillRect(-1, 0, 2, 1); // nose
  ctx.fillStyle='#000';
  ctx.fillRect(-2, -1, 1, 1); // eyes
  ctx.fillRect(1, -1, 1, 1);

  // Dress (blue pin-striped pinafore)
  ctx.fillStyle='#7db6ff'; ctx.fillRect(-5, 7, 10, 6);
  ctx.fillStyle='#5fa0ff'; for(let i=-4;i<=4;i+=2) ctx.fillRect(i,7,1,6); // pin-stripes

  // Tote (if powered) ‚Äî shine a bit
  if (p.powerTote){
    ctx.save(); ctx.translate(5,8); ctx.fillStyle='#f5e6c8'; ctx.fillRect(-3,-2,6,4); ctx.fillStyle='#e6d6b6'; ctx.fillRect(-2,-4,4,2);
    ctx.fillStyle='#c59'; ctx.fillRect(-1,0,2,1);
    if ((frame%20)<10){ ctx.fillStyle='#fff'; ctx.fillRect(2,-4,1,1); }
    ctx.restore();
  }

  // Feet (frame-based)
  const runPh = Math.abs(p.vx)*0.5 + (p.onGround? (frame*0.2):0);
  const fx = Math.sin(runPh)*1.2;
  ctx.fillStyle='#e8e4d8';
  ctx.fillRect(-3+fx, 13, 3, 2);
  ctx.fillRect( 1-fx, 13, 3, 2);

  // Simple state emblem: jumping/gliding small cape-like shape
  if (!p.onGround){
    if (p.gliding){ ctx.fillStyle='#bde0fe'; ctx.fillRect(-6,10,12,2); }
  }

  ctx.restore();
}

// ======================
// Particles & effects
// ======================
function spawnSpark(x,y,color='#ffd166'){ for(let i=0;i<8;i++){ const p = particles.find(p=>!p.active); if(!p) return; p.init(x,y, rnd(-0.8,0.8), rnd(-1.2,-0.2), irnd(20,40), color); } }
function spawnSparkle(x,y){ spawnSpark(x,y,'#fff7cc'); }
function spawnConfetti(x,y){ for(let i=0;i<80;i++){ const p = particles.find(p=>!p.active); if(!p) return; const c = ['#ff7aa2','#ffd166','#7ee081','#7db6ff'][i%4]; p.init(x,y, rnd(-1,1), rnd(-2,-0.5), irnd(30,70), c); } }
function addFloat(x,y,text){ const f = floaters.find(f=>!f.active); if(!f) return; f.init(x,y,text); }

// ======================
// Game Loop (fixed timestep)
// ======================
let accum=0, last=performance.now();
function loop(now){
  requestAnimationFrame(loop);
  const dt = Math.min(100, now-last); last=now; accum += dt;
  while (accum >= 1000/60){ tick(); accum -= 1000/60; }
  render();
}
requestAnimationFrame(loop);

function setCameraToPlayer(L){
  const targetX = player.x - CONFIG.WIDTH*0.4 + (player.vx*10);
  camera.x = lerp(camera.x, clamp(targetX, 0, L.w*CONFIG.TILE - CONFIG.WIDTH), CONFIG.CAMERA_LERP);
  camera.y = lerp(camera.y, 0, CONFIG.CAMERA_LERP*0.5);
}

function tick(){
  if (gameState!==STATE.PLAYING) return;
  if (paused){ return; }
  frame++;
  stats.time += 1/60;
  updateHUD();
  const L = levels[stageIndex];

  // update moving platforms
  for (const p of entities.plats){
    const t = frame%200;
    p.x = p.origin.x + p.dir * Math.sin((frame%600)/600 * Math.PI*2) * p.range/2;
  }

  // Player physics & collisions
  updatePlayer(L);

  // Foxes
  for (const fx of entities.foxes){ updateFox(L, fx); }

  // Particles
  for (const p of particles) if (p.active) p.upd();
  for (const f of floaters) if (f.active) f.upd();

  // camera
  setCameraToPlayer(L);

  // Screen shake decay
  shake *= CONFIG.SHAKE_DECAY;
}

function updateHUD(){
  hudCarrot.textContent = 'ü•ï x ' + String(stats.carrots).padStart(2,'0');
  hudLives.textContent  = '‚ù§ x ' + stats.lives;
  hudPower.textContent  = player && player.powerTote? 'üëú Tote' : 'üëú ‚Äî';
  const t = Math.floor(stats.time);
  const m = Math.floor(t/60), s = t%60; hudTime.textContent = `‚è± ${m}:${String(s).padStart(2,'0')}`;
}

function updatePlayer(L){
  if (respawnTimer>0){ respawnTimer--; if (respawnTimer===0) respawn(); return; }

  const p = player;

  // input move
  let ax = 0;
  if (input.left && !input.right) ax = -CONFIG.AIR_ACCEL;
  if (input.right && !input.left) ax = CONFIG.AIR_ACCEL;
  p.vx = clamp(p.vx + ax, -CONFIG.MOVE_SPEED, CONFIG.MOVE_SPEED);
  if (!input.left && !input.right) p.vx *= (p.onGround? CONFIG.FRICTION_GROUND : CONFIG.FRICTION_AIR);
  if (p.vx>0.05) p.dir=1; else if (p.vx<-0.05) p.dir=-1;

  // coyote & jump buffering
  if (p.onGround) p.coyote = CONFIG.COYOTE_TIME; else p.coyote--;
  if (input.jump){ p.jumpBuffer=CONFIG.JUMP_BUFFER; input.jump=false; } else p.jumpBuffer--;

  // Jump
  if (p.jumpBuffer>0 && p.coyote>0){ p.vy = CONFIG.JUMP_VELOCITY; p.onGround=false; p.coyote=0; p.jumpBuffer=0; audio.playJump(); }
  // Variable jump height
  if (!input.jumpHeld && p.vy < 0) p.vy *= CONFIG.VAR_JUMP_CUT;

  // Glide
  p.gliding = false;
  if (!p.onGround && p.powerTote && input.jumpHeld && p.vy>0){ p.gliding=true; }

  // gravity
  p.vy += (p.gliding? CONFIG.GLIDE_GRAVITY : CONFIG.GRAVITY);
  p.vy = clamp(p.vy, -999, CONFIG.MAX_FALL);

  // Collision rect
  const r = p.rect();
  const res = resolveSolids(L, r, p.vx, p.vy);
  const wasGround = p.onGround;
  p.onGround = res.onGround;
  if (res.collidedX) p.vx = 0;
  if (res.onGround){ p.vy = 0; if (!wasGround){ p.landingSquash = 12; audio.playLand(); }}
  if (res.hitHead && p.vy<0) p.vy=0; // bonk
  if (res.hurt){ player.hurt(); }

  // Integrate back to pos
  p.x = r.x + p.w/2; p.y = r.y + p.h;
  if (p.landingSquash>0) p.landingSquash--;
  if (p.invuln>0) p.invuln--;

  // Platforms riding
  for (const pl of entities.plats){
    const pr = pl.rect(); const rr = p.rect(); rr.y += 1; // slightly below feet
    if (rectVsRect(rr, pr) && p.vy>=0){
      // Stand on platform
      p.y = pr.y; p.onGround=true; p.vy=0; // lock to top
      // move with platform
      p.x += (pl.x - pl.prevX)||0; p.y += (pl.y - pl.prevY)||0;
    }
  }
  // store prev positions for platforms
  for (const pl of entities.plats){ pl.prevX=pl.x; pl.prevY=pl.y; }

  // Entity interactions
  // Carrots
  for (const c of entities.carrots){ if (!c.collected){
    if (Math.hypot(p.x - c.x, p.y-8 - c.y) < 10){ c.collected=true; stats.carrots++; addFloat(c.x, c.y-8, '+1'); audio.playCarrot(); spawnSparkle(c.x, c.y-8); }
  }}
  // Tote
  for (const t of entities.totes){ if (!t.collected){
    if (Math.hypot(p.x - t.x, p.y-8 - t.y) < 10){ t.collected=true; p.giveTote(); }
  }}
  // Checkpoints
  for (const cp of entities.checkpoints){
    if (Math.abs(p.x - cp.x) < 10 && Math.abs(p.y - cp.y) < 16 && !cp.activated){
      cp.activated=true; lastCheckpoint = { level: stageIndex, x: cp.x, y: cp.y };
      stats.lives = clamp(stats.lives + CONFIG.CHECKPOINT_HEAL, 0, CONFIG.PLAYER_MAX_LIVES);
      audio.playCheckpoint(); spawnSpark(cp.x, cp.y-8, '#ffd166');
    }
  }
  // Goal
  if (entities.goal){ const g=entities.goal; if (!g.hit && Math.abs(p.x - g.x) < 10 && Math.abs(p.y - g.y) < 20){ g.hit=true; levelComplete(); } }

  // Fox collisions (stomp vs hurt)
  for (const fx of entities.foxes){ if (fx.remove>0) continue; const rr = fx.rect(); const pr = p.rect(); if (rectVsRect(pr, rr)){
      const overlapY = (p.y - p.h) - (fx.y - fx.h);
      const descending = p.vy>0 && (p.y - p.h) < (fx.y - fx.h/2);
      if (descending && fx.stun===0){ // stomp
        p.stompBounce(); fx.stun = CONFIG.FOX_STUN_TIME; fx.vx=0; fx.vy=0; spawnSpark(fx.x, fx.y-8, '#ffa94d');
      } else if (fx.stun>0){ /* ignore */ }
      else { p.hurt(); if (!p.dead){ // knockback
          p.vx = -p.dir*1.2; p.vy = -3.5; shake=5; }
      }
  }}

  // Pits respawn
  if (p.y > CONFIG.HEIGHT + 40){ player.hurt(); }
}

function updateFox(L, f){
  if (f.remove>0){ f.remove--; return; }
  if (f.stun>0){ f.stun--; if (f.stun===0){ f.remove=30; } return; }
  // Patrol
  f.x += f.vx * f.dir;
  // turn at edges or walls
  const aheadX = f.x + f.dir*8;
  const aheadY = f.y;
  const tileAhead = tileAt(L, aheadX, aheadY);
  const tileBelow = tileAt(L, aheadX, aheadY+1);
  if (solidTile(tileAhead) || !solidTile(tileBelow)) f.dir*=-1;

  // gravity
  f.vy += CONFIG.GRAVITY; if (f.vy>CONFIG.MAX_FALL) f.vy=CONFIG.MAX_FALL; f.y += f.vy;
  // floor collide
  const r = f.rect();
  const below = tileAt(L, f.x, f.y+1);
  if (solidTile(below)) { // simple snap to grid bottom
    f.vy=0; f.y = Math.floor(f.y/CONFIG.TILE)*CONFIG.TILE;
  }
}

function respawn(){
  const L = levels[stageIndex];
  if (stats.lives<=0){ // game over ‚Üí back to title
    setState(STATE.TITLE); return;
  }
  if (lastCheckpoint && lastCheckpoint.level===stageIndex){
    player = new Player(lastCheckpoint.x, lastCheckpoint.y);
  } else {
    const sx = L.start[0]*CONFIG.TILE + 8, sy = (L.start[1]+1)*CONFIG.TILE;
    player = new Player(sx, sy);
  }
}

function levelComplete(){
  audio.playGoal(); spawnConfetti(player.x, player.y-16);
  // next stage or ending
  if (stageIndex < levels.length-1){
    // small celebratory delay then next stage
    setTimeout(()=>{ stageIndex++; initStage(stageIndex); }, 1200);
  } else {
    // Epic Ending
    setTimeout(()=> endSequence(), 1200);
  }
}

function endSequence(){
  setState(STATE.END);
  const t = Math.floor(stats.time); const m=Math.floor(t/60), s=t%60;
  document.getElementById('endStats').textContent = `Total Carrots: ${stats.carrots}\nTime: ${m}:${String(s).padStart(2,'0')}`;
}

// ======================
// Render
// ======================
function render(){
  const L = levels[stageIndex] || levels[0];

  // letterbox shake transform
  ctx.save();
  const sx = (Math.random()-0.5)*shake; const sy=(Math.random()-0.5)*shake;
  ctx.translate(sx, sy);

  // Background (screen-space)
  drawSky();

  // World-space
  ctx.save();
  ctx.translate(-Math.floor(camera.x), -Math.floor(camera.y));

  drawLevelTiles(L);

  // moving platforms
  for (const p of entities.plats){ drawPlatform(p); }

  // carrots/totes/checkpoints/goal
  for (const c of entities.carrots) if(!c.collected) drawCarrot(c.x, c.y);
  for (const t of entities.totes) if(!t.collected) drawTote(t.x, t.y);
  for (const cp of entities.checkpoints) drawCheckpoint(cp);
  if (entities.goal) drawGoal(entities.goal
// ======================
